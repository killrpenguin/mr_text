use std::io::{BufRead, ErrorKind, Write};

mod ffi {
    use std::{io, mem::MaybeUninit, os::fd::AsRawFd};

    pub fn tcgetattr(stream: &mut impl AsRawFd) -> io::Result<libc::termios> {
        let mut result = MaybeUninit::uninit();
        let fd = stream.as_raw_fd();
        let ptr = result.as_mut_ptr();
        let status = unsafe { libc::tcgetattr(fd, ptr) };
        if status != 0 {
            Err(io::Error::last_os_error())
        } else {
            Ok(unsafe { result.assume_init() })
        }
    }

    pub fn tcsetattr(stream: &mut impl AsRawFd, og_term: libc::termios) -> io::Result<()> {
        let fd = stream.as_raw_fd();
        let status = unsafe { libc::tcsetattr(fd, libc::TCSADRAIN, &og_term) };
        if status != 0 {
            Err(io::Error::last_os_error())
        } else {
            Ok(())
        }
    }

    pub fn configure_terminal(
        stream: &mut impl AsRawFd,
        og_termios: libc::termios,
    ) -> io::Result<()> {
        let mut intended = og_termios;
        intended.c_iflag &= !(libc::BRKINT | libc::ICRNL | libc::INPCK | libc::ISTRIP | libc::IXON);
        intended.c_oflag &= !(libc::OPOST);
        intended.c_cflag |= libc::CS8;
        intended.c_lflag &= !(libc::ECHO | libc::ICANON | libc::IEXTEN | libc::ISIG);

        tcsetattr(stream, intended)?;

        let new_termios = tcgetattr(stream)?;
        if new_termios.c_iflag != intended.c_iflag
            || new_termios.c_oflag != intended.c_oflag
            || new_termios.c_cflag != intended.c_cflag
            || new_termios.c_lflag != intended.c_lflag
        {
            return Err(io::Error::other("termios not fully configured as intended"));
        }

        Ok(())
    }
}
pub fn clear_screen(ostream: &mut std::io::StdoutLock) {
    write!(ostream, "\u{1b}[2J").unwrap();
    ostream.flush().unwrap();
}

fn main() {
    let mut istream = std::io::stdin().lock();
    let mut ostream = std::io::stdout().lock();

    clear_screen(&mut ostream);
    let original_term = ffi::tcgetattr(&mut istream).unwrap();
    ffi::configure_terminal(&mut istream, original_term).unwrap();

    loop {
        let buf = match istream.fill_buf() {
            Ok(buf) => buf,
            Err(e) if e.kind() == ErrorKind::Interrupted => continue,
            error => error.unwrap(),
        };
        if buf.is_empty() {
            break;
        }
        let pos = buf.iter().position(|&b| b == 0x11); 
        let mut start = 0;
        let mut end = pos.unwrap_or(buf.len());

        // Optional: validate UTF-8, replacing invalid byte sequences
        while let Err(err) = std::str::from_utf8(&buf[start..end]) {
            match err.error_len() {
                Some(invalid) => {
                    let valid = start + err.valid_up_to();
                    ostream.write_all(&buf[start..valid]).unwrap();
                    write!(ostream, "{}", char::REPLACEMENT_CHARACTER).unwrap();
                    start = valid + invalid;
                }
                None => {
                    end = start + err.valid_up_to();
                    break;
                }
            }
        }

        ostream.write_all(&buf[start..end]).unwrap();
        ostream.flush().unwrap();
        istream.consume(end);

        if pos.is_some() {
            istream.consume(1);
            break;
        }
    }

    ffi::tcsetattr(&mut istream, original_term).unwrap();
}
